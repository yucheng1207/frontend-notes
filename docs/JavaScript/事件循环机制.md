# 事件循环机制

## 浏览器环境

由于js是一个单线程，为了处理异步的情况引入了事件队列机制。当js引擎遇到异步事件时不会一直等待其返回结果，而是将这个事件挂起，继续执行`执行栈`的任务，当异步事件返回结果后，也不会立即执行其回调，而是将其加入到一个事件队列中，等当前执行栈中的所有任务都执行完毕，主线程处于闲置状态时，主线程会去查找事件队列是否有任务,如果有则从队列中取出事件回调去执行。而队列中的任务又分为“微任务”和“宏任务”。

- 微任务
    - new Promise()
    - new MutaionObserver()
    - Object.observe
- 宏任务
    - I/O
        - I/O这一项感觉有点儿笼统，有太多的东西都可以称之为I/O，点击一次button，上传一个文件，与程序产生交互的这些都可以称之为I/O。
    - setInterval()
    - setTimeout()
    - requestAnimationFrame
        - requestAnimationFrame姑且也算是宏任务吧，requestAnimationFrame在[MDN的定义](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame)为下次页面重绘前所执行的操作，而重绘也是作为宏任务的一个步骤来存在的，且该步骤晚于微任务的执行


具体规则为**当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。**


## node环境

### 与浏览器环境有何不同?
在node中，事件循环表现出的状态与浏览器中大致相同。不同的是node中有一套自己的模型。node中事件循环的实现是依靠的libuv引擎。我们知道node选择chrome v8引擎作为js解释器，v8引擎将js代码分析后去调用对应的node api，而这些api最后则由libuv引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上node中的事件循环存在于libuv引擎中。

### node事件循环模型
![node事件循环模型](https://raw.githubusercontent.com/Coder-1024/image-host/main/imgs/frontend_notes/js-事件循环机制-node事件循环模型.jpg)

从上面这个模型中，我们可以大致分析出node中的事件循环的顺序：

外部输入数据-->轮询阶段(poll)-->检查阶段(check)-->关闭事件回调阶段(close callback)-->定时器检测阶段(timer)-->I/O事件回调阶段(I/O callbacks)-->闲置阶段(idle, prepare)-->轮询阶段...

- timers: 这个阶段执行定时器队列中的回调如 `setTimeout()` 和 `setInterval()`。
- I/O callbacks: 这个阶段执行几乎所有的回调。但是不包括`close事件`，`定时器`和`setImmediate()`的回调。
- idle, prepare: 这个阶段仅在内部使用，可以不必理会。
- poll: 等待新的I/O事件，node在一些特殊情况下会阻塞在这里。
    - 当个v8引擎将js代码解析后传入libuv引擎后，循环**首先进入**poll阶段
- check: `setImmediate()`的回调会在这个阶段执行。
- close callbacks: 例如socket.on('close', ...)这种close事件的回调。
    - 当一个socket连接或者一个handle被突然关闭时（例如调用了socket.destroy()方法），close事件会被发送到这个阶段执行回调。否则事件会用process.nextTick（）方法发送出去。

### process.nextTick,setTimeout与setImmediate的区别与使用场景
在node中有三个常用的用来推迟任务执行的方法：process.nextTick,setTimeout（setInterval与之相同）与setImmediate

#### process.nextTick()
尽管没有提及，但是实际上node中存在着一个特殊的队列，即nextTick queue。这个队列中的回调执行虽然没有被表示为一个阶段，当时这些事件却会在每一个阶段执行完毕准备进入下一个阶段时优先执行。当事件循环准备进入下一个阶段之前，会先检查nextTick queue中是否有任务，如果有，那么会先清空这个队列。与执行poll queue中的任务不同的是，这个操作在队列清空前是不会停止的。这也就意味着，错误的使用`process.nextTick()`方法会导致node进入一个死循环。。直到内存泄漏。

`process.nextTick`可以认为是一个类似于`Promise`和`MutationObserver`的微任务实现，在代码执行的过程中可以随时插入`nextTick`，并且会保证在下一个宏任务开始之前所执行。

**在使用方面的一个最常见的例子就是一些事件绑定类的操作：**
```js
class Lib extends require('events').EventEmitter {
  constructor () {
    super()

    this.emit('init')
  }
}

const lib = new Lib()

lib.on('init', _ => {
  // 这里将永远不会执行
  console.log('init!')
})
```
因为上述的代码在实例化Lib对象时是同步执行的，在实例化完成以后就立马发送了init事件。
而这时在外层的主程序还没有开始执行到lib.on('init')监听事件的这一步。
所以会导致发送事件时没有回调，回调注册后事件不会再次发送。
我们可以很轻松的使用process.nextTick来解决这个问题：
```js
class Lib extends require('events').EventEmitter {
  constructor () {
    super()

    process.nextTick(_ => {
      this.emit('init')
    })

    // 同理使用其他的微任务
    // 比如Promise.resolve().then(_ => this.emit('init'))
    // 也可以实现相同的效果
  }
}
```
这样会在主进程的代码执行完毕后，程序空闲时触发Event Loop流程查找有没有微任务，然后再发送init事件。

#### setTimeout()和setImmediate()
- setImmediate为一次Event Loop执行完毕后调用。
- setTimeout则是通过计算一个延迟时间后进行执行。

setTimeout()和不设置时间间隔的setImmediate()表现上及其相似。猜猜下面这段代码的结果是什么？
```js
setTimeout(() => {
    console.log('timeout');
}, 0);

setImmediate(() => {
    console.log('immediate');
});
```
实际上，**答案是不一定**。没错，就连node的开发者都无法准确的判断这两者的顺序谁前谁后。这取决于这段代码的运行环境。运行环境中的各种复杂的情况会导致在同步队列里两个方法的顺序随机决定。但是，在一种情况下可以准确判断两个方法回调的执行顺序，那就是在一个I/O事件的回调中。下面这段代码的顺序永远是固定的：

```js
const fs = require('fs');

fs.readFile(__filename, () => {
    setTimeout(() => {
        console.log('timeout');
    }, 0);
    setImmediate(() => {
        console.log('immediate');
    });
});
```
答案永远是：
```
immediate
timeout
```
**因为在I/O事件的回调中，setImmediate方法的回调永远在timer的回调前执行。**

而下面这种情况可以确保setTimeout先执行，但正常情况下我们不会这么写：
```js
setTimeout(_ => console.log('setTimeout'))
setImmediate(_ => console.log('setImmediate'))

let countdown = 1e9

// 我们确保这个循环的执行速度会超过定时器的倒计时，导致这轮循环没有结束时，setTimeout已经可以执行回调了
// 所以会先执行`setTimeout`再结束这一轮循环，也就是说开始执行`setImmediate`
while(countdown--) { }
```


# 浏览器 vs node
![宏任务](https://raw.githubusercontent.com/Coder-1024/image-host/main/imgs/frontend_notes/js-事件循环机制-宏任务.jpg)
![微任务](https://raw.githubusercontent.com/Coder-1024/image-host/main/imgs/frontend_notes/js-事件循环机制-微任务.jpg)

node中新增微任务的`process.nextTick`以及宏任务的`setImmediate`。


# 例子
```js
setTimeout(_ => console.log(4))

new Promise(resolve => {
  resolve()
  console.log(1)
}).then(_ => {
  console.log(3)
  Promise.resolve().then(_ => {
    console.log('before timeout')
  }).then(_ => {
    Promise.resolve().then(_ => {
      console.log('also before timeout')
    })
  })
})

console.log(2)

// 输出
// 1
// 2
// 3
// before timeout
// also before timeout
// 4
```

# 参考
- [详解JavaScript中的Event Loop（事件循环）机制](https://zhuanlan.zhihu.com/p/33058983)
- [微任务、宏任务与Event-Loop](https://juejin.cn/post/6844903657264136200)
- [setTimeout和requestAnimationFrame](https://juejin.cn/post/6844904083204079630)