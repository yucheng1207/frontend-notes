# 数据类型

## 7种[原始类型](https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive)(基本类型、基本数据类型）
> 基本数据类型的值是按值访问的

一种既非对象也无方法的数据，所有基本类型的值都是**不可改变的**。但需要注意的是，基本类型本身和一个赋值为基本类型的变量的区别。变量会被赋予一个新值，而原值不能像数组、对象以及函数那样被改变。


- [undefined](https://developer.mozilla.org/zh-CN/docs/Glossary/undefined)：一个声明未定义的变量的初始值，或没有实际参数的形式参数。`typeof instance === "undefined"`
- [Boolean](https://developer.mozilla.org/zh-CN/docs/Glossary/Boolean)：布尔值是一种取值仅能为 真 或 假 的数据类型。`typeof instance === "boolean"`
- [Number](https://developer.mozilla.org/zh-CN/docs/Glossary/Number)：Number 是一种 定义为 64位双精度浮点型的数字数据类型。Infinity、NaN都是数字类型。`typeof instance === "number"`
- [String](https://developer.mozilla.org/zh-CN/docs/Glossary/String)：字符串类型。`typeof instance === "string"`
- [BigInt](https://developer.mozilla.org/zh-CN/docs/Glossary/BigInt)：BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数。`typeof instance === "bigint"`
- [Symbol](https://developer.mozilla.org/zh-CN/docs/Glossary/Symbol) ：符号类型值。在 JavaScript 运行时环境中，一个符号类型值可以通过调用函数 `Symbol()` 创建，这个函数动态地生成了一个**匿名，唯一**的值。Symbol类型唯一合理的用法是用变量存储 symbol的值，然后使用存储的值创建对象属性。`typeof instance === "symbol"`
    ```
    var  myPrivateMethod  = Symbol();
    this[myPrivateMethod] = function() {...};
    ```
- [null](https://developer.mozilla.org/zh-CN/docs/Glossary/Null)：表示一个不存在或者无效


## [引用类型/Object 类型](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures#%E5%AF%B9%E8%B1%A1)
> 引用类型的值是按引用访问的。查看[所有的内置对象](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects)

除过上面的 7 种基本数据类型外，剩下的就是引用类型了，统称为 Object 类型。细分的话，有：Object 类型、Array 类型、Date 类型、RegExp 类型、Function 类型 等。`typeof instance === "object"。`

- [Object](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object)("标准的"对象)：一个 JavaScript 对象就是键和值之间的映射。键是一个字符串（或者 Symbol），值可以是任意类型的值。
- Function(函数)：一个附带可被调用功能的常规对象。
- Date(日期)：内建的 Date 对象。
- 有序集
    - [数组](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)：是一种使用整数作为键(integer-key-ed)属性和长度(length)属性之间关联的常规对象。此外，数组对象还继承了 Array.prototype 的一些操作数组的便捷方法。例如, indexOf (搜索数组中的一个值) or push (向数组中添加一个元素），等等。 这使得数组是表示列表或集合的最优选择。
    - [类型数组](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays):是 ECMAScript Edition 6 中新定义的 JavaScript 内建对象，提供了一个基本的二进制数据缓冲区的类数组视图。(Int8Array、Uint8Array、Int16Array等)
- 键控集
    - Maps
    - Sets
    - WeakMaps
    - WeakSets
- 结构化数据
    - JSON


> 记住 typeof 操作符的唯一目的就是检查数据类型，如果我们希望检查任何从 Object 派生出来的结构类型，使用 typeof 是不起作用的，因为总是会得到 "object"。检查 Object 种类的合适方式是使用 instanceof 关键字。但即使这样也存在误差。

## 判断类型的方法

### [typeof](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof)
经常用来检测一个变量是不是最基本的数据类型
**适合用于比较简单的场景，如特定类型判断，是否是字符串、是否是函数等**
```
var a;
typeof a;    // undefined

a = null;
typeof a;    // object

a = true;
typeof a;    // boolean

a = 666;
typeof a;    // number

a = "hello";
typeof a;    // string

a = Symbol();
typeof a;    // symbol

a = function(){}
typeof a;    // function

a = [];
typeof a;    // object
a = {};
typeof a;    // object
a = /aaa/g;
typeof a;    // object
```

优点：
- 使用起来简单，基本数据类型值基本上都可以有效检测，引用数据类型值也可以检测出来

局限性：
- NaN / Infinity/ 2 都是数字类型的，检测结果都是“number”;
- typeof null 的结果是“object”;
- Date/Object/RegExp/Number 都是返回function，不能判断具体类型
- {}/[] 都是返回"object"，无法基于typeof 区分是普通对象还是数组对象

> 这是浏览器的BUG：所有的值在计算中都以二进制编码储存，浏览器中把前三位000的当作对象，而null的二进制前三位是000，所以被识别为对象，但是他不是对象，他是空对象指针，是基本类型值


### [instanceof](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof)
用来判断某个构造函数的 prototype 属性所指向的对象是否存在于另外一个要检测对象的原型链上
简单说就是判断一个引用类型的变量具体是不是某种类型的对象（注意：instanceof 后面一定要是对象类型，并且大小写不能错）
**适合用于判断【自定义的类】实例对象, 而不是用来判断原生的数据类型**
```
({}) instanceof Object              // true
([]) instanceof Array               // true
(/aa/g) instanceof RegExp           // true
(function(){}) instanceof Function  // true
```

优点：
- 可以弥补 typeof无法细分对象类型的缺点（想检测这个值是否为数组，只需要看他是否为Array类的实例即可）

局限性：
- 要求检测的实例必须是对象数据类型的
- 不能检测出基本数据类型, 构造函数创建的可以检测
- 不管是数组对象还是正则对象，都是Object的实例，检测结果都是true，所以无法基于这个结果判断是否为普通对象

### Object.prototype.toString
返回一个表示该对象的字符串
**适合用于检查【内置类】**

[使用Object.prototype.toString检查对象类型](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString#%E4%BD%BF%E7%94%A8_tostring()_%E6%A3%80%E6%B5%8B%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B)
> Object.prototype.toString 的原理是当调用的时候, 就取值内部的 [[Class]] 属性值, 然后拼接成 '[object ' + [[Class]] + ']'  这样的字符串并返回. 然后我们使用 call 方法来获取任何值的数据类型.

```
Object.prototype.toString.call("123")           // [object String]
Object.prototype.toString.call(123)             // [object Number]
Object.prototype.toString.call(new Date());     // [object Date]
Object.prototype.toString.call(true);           // [object Boolean]
Object.prototype.toString.call([1,2,3]);        // [object Array]
Object.prototype.toString.call(function () {}); // [object Function]
Object.prototype.toString.call(Math);           // [object Math]
Object.prototype.toString.call(undefined);      // [object Undefined]
Object.prototype.toString.call(null);           // [object Null]
Object.prototype.toString.call(/\d/);           // [object RegExp]
Object.prototype.toString.call(Symbol);         // [object Symbol]
```

优点：
- 专门用来检测数据类型的方法，基本上不存在局限性的数据类型检测方式 基于他可以有效的检测任何数据类型的值

局限性：
- 只能检测内置类，不能检测出自定义类和结构函数
- 只要是自定义类返回的都是‘[Object Function]’

此方法是基于JS本身专门进行数据检测的，所以是目前检测数据类型比较好的方法。

### 最终方法
#### 内置类都可以用来检测。

```js
function _typeof(obj){
  var s = Object.prototype.toString.call(obj);
  return s.match(/\[object (.*?)\]/)[1].toLowerCase();
};
// or
function type(obj) {
  return typeof obj !== "object" ? typeof obj : Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();
}
```


#### 单独检测
```js
/**
 * @desc 是否是 Undefined 类型检测
 * @param obj 待检测的数据
 * @return {Boolean} 布尔值
 */
function isUndefined(obj) {
    return obj === void 0;
}
/**
 * @desc 是否是 Null 类型检测
 * @param obj 待检测的数据
 * @return {Boolean} 布尔值
 */
function isNull(obj) {
    return obj === null;
}
/**
 * @desc 是否是 Boolean 类型检测
 * @param obj 待检测的数据
 * @return {Boolean} 布尔值
 */
function isBoolean(obj) {
    return typeof(obj) === 'boolean';
}
/**
 * @desc 是否是 Number 类型检测
 * @param obj 待检测的数据
 * @return {Boolean} 布尔值
 */
function isNumber(obj) {
    return typeof(obj) === 'number';
}
/**
 * @desc 是否是 String 类型检测
 * @param obj 待检测的数据
 * @return {Boolean} 布尔值
 */
function isString(obj) {
    return typeof(obj) === 'string';
}
/**
 * @desc 是否是 Object 类型检测
 * @param obj 待检测的数据
 * @return {Boolean} 布尔值
 */
function isObject(obj) {
    return Object.prototype.toString.call(obj) === '[object Object]';
}
/**
 * @desc 是否是 Array 类型检测
 * @param obj 待检测的数据
 * @return {Boolean} 布尔值
 */
function isArray(obj){
    return Array.isArray?Array.isArray(obj):Object.prototype.toString.call(obj) === '[object Array]';
}
/**
 * @desc 是否是 Function 类型检测
 * @param obj 待检测的数据
 * @return {Boolean} 布尔值
 */
function isFunction(obj){
    return typeof(obj) === 'function';
}
/**
 * @desc 是否是 Date 类型检测
 * @param obj 待检测的数据
 * @return {Boolean} 布尔值
 */
function isDate(obj){
    return Object.prototype.toString.call(obj) === '[object Date]';
}
/**
 * @desc 是否是 RegExp 类型检测
 * @param obj 待检测的数据
 * @return {Boolean} 布尔值
 */
function isRegExp(obj){
    return Object.prototype.toString.call(obj) === '[object RegExp]';
}
/**
 * @desc 是否是 Error 类型检测
 * @param obj 待检测的数据
 * @return {Boolean} 布尔值
 */
function isError(obj){
    return Object.prototype.toString.call(obj) === '[object Error]';
}
/**
 * @desc 是否是 Arguments 类型检测
 * @param obj 待检测的数据
 * @return {Boolean} 布尔值
 */
function isArguments(obj){
    return Object.prototype.toString.call(obj) === '[object Arguments]';
}
```


# 参考
- [JavaScript 数据类型和数据结构 - MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures)
- [JavaScript 深入了解基本类型和引用类型的值 - 菜鸟教程](https://www.runoob.com/w3cnote/javascript-basic-types-and-reference-types.html)